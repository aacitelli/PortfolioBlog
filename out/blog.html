<!DOCTYPE html><html><head><script data-ad-client="ca-pub-7827406820675555" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5Y70JBTCJ1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-5Y70JBTCJ1', {
              page_path: window.location.pathname,
            });
          </script><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-2140933378"/><meta charSet="utf-8" class="jsx-2140933378"/><meta name="Description" content="Full of my thoughts on all sorts of useful things!" class="jsx-2140933378"/><title class="jsx-2140933378">Blog - Anden Acitelli</title><noscript data-n-css="true"></noscript><link rel="preload" href="./_next/static/chunks/main-e42d054aa95b944b20b8.js" as="script"/><link rel="preload" href="./_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="./_next/static/chunks/framework.1d36bc031662b4dc4c28.js" as="script"/><link rel="preload" href="./_next/static/chunks/commons.8efcb680d37dd3ee49c0.js" as="script"/><link rel="preload" href="./_next/static/chunks/56d41ae4a9190e27ed3b62860efb4e91cb9f6cf4.413db218b03418cdd16a.js" as="script"/><link rel="preload" href="./_next/static/chunks/pages/_app-c80169169d682623989a.js" as="script"/><link rel="preload" href="./_next/static/chunks/ce1ec70fd8cb3022c6ba5208dd089b6243e5bf76.d2c9cf82cc172977f3f6.js" as="script"/><link rel="preload" href="./_next/static/chunks/pages/blog-66917b58afde6367a706.js" as="script"/><style id="__jsx-2140933378">@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;800;900&display=swap');html,body{margin:0;padding:0;font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI', Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue', sans-serif;color:#445566;}h1,h2,h3,h4,h5,h6{font-weight:bold;}a{color:#00a395;}.content{padding:2rem 20px;-webkit-flex:1;-ms-flex:1;flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}footer{width:100%;height:100px;border-top:1px solid #eaeaea;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}footer img{padding:0 5px;height:1rem;}</style><style id="__jsx-3244163938">header.jsx-3244163938{width:100%;height:60px;border-bottom:1px solid #eaeaea;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}nav.jsx-3244163938{width:calc(100% - 40px);max-width:1200px;font-weight:bold;font-size:1.3rem;}nav.jsx-3244163938 a.jsx-3244163938{margin-right:20px;color:#00a395;-webkit-text-decoration:none;text-decoration:none;}nav.jsx-3244163938 a.jsx-3244163938:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><style id="__jsx-301565434">a.jsx-301565434{color:rgb(64,64,64);}</style><style id="__jsx-3617506183">.title.jsx-3617506183{margin:1rem auto;font-size:3rem;}</style></head><body><div id="__next"><section class="jsx-2140933378 layout"><header class="jsx-3244163938 header"><nav role="navigation" aria-label="main navigation" class="jsx-3244163938 nav"><a class="jsx-3244163938" href="/">About Me</a><a class="jsx-3244163938" href="/blog">Articles List</a></nav></header><div class="jsx-2140933378 content"><h1 class="jsx-3617506183 title">Blog</h1><p class="jsx-3617506183 description">Still have to make this page look nice, but here&#x27;s all my posts!</p><main class="jsx-3617506183"><div class="jsx-301565434"><ul class="jsx-301565434"><li class="jsx-301565434">May 22, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/coding-challenges-and-whiteboarding-a-comprehensive-guide">Coding Challenges &amp; Whiteboarding - A Comprehensive Guide</a></li><li class="jsx-301565434">May 21, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/leetcode-1725">Leetcode #1725 - Number Of Rectangles That Can Form The Largest Square | Python Solution &amp; Walkthrough</a></li><li class="jsx-301565434">May 21, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/leetcode-1828">Leetcode #1828 - Queries on Number of Points Inside a Circle | Python Solution &amp; Walkthrough</a></li><li class="jsx-301565434">May 21, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/time-and-space-complexity-a-review">Time &amp; Space Complexity | A Review</a></li><li class="jsx-301565434">May 20, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/computer-science-job-search-guide">A Guide to Getting a Job as a Computer Science Student</a></li><li class="jsx-301565434">May 20, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/leetcode-200">Leetcode #200 - Number of Islands | Python Solution &amp; Walkthrough</a></li><li class="jsx-301565434">May 19, 2021<!-- -->: <!-- --> <a class="jsx-301565434" href="/blog/leetcode-1832">Leetcode #1832 - Check if the Sentence Is Pangram | Python Solution &amp; Walkthrough</a></li></ul></div></main></div></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"frontmatter":{"title":"Coding Challenges \u0026 Whiteboarding - A Comprehensive Guide","author":"Anden Acitelli","date":"2021-05-22"},"markdownBody":"\r\n## Intro \r\nWriting code in an assessment environment is a source of anxiety for a lot of people. I've done more research into it than the average person, so I figured I'd summarize all the advice I've internalized up to this point. This guide is intended as a concise overview of my recommended strategies, both before and during the interview. \r\n\r\n## Before the Interview\r\nFollow these steps:\r\n\r\n1. Make sure you have Time/Space complexity down. You *need* to be able to program with that in mind. \r\n    - [I have a guide on it](/blog/time-and-space-complexity-a-review); there are lots of great guides out there on the internet as well.\r\n2. Study your Data Structures \u0026 Algorithms. You don't need to be perfect, but you should understand the major ones and the general circumstances where you'd want to use them (i.e. use a set when order doesn't matter, )\r\n\r\n## During the Interview\r\n### Coding Challenges\r\nFor coding challenges, you want to submit something that works, then work on optimizing it. Something that works is generally prioritized over something super efficient, but with a lot of higher-tier companies especially you'll need to get them all working *and* have something pretty efficient to get through their screening rounds. \r\n\r\nMy general process is the following:\r\n\r\n1. Check all the questions and get a rough idea of how tough they all are.\r\n    - Your exact process may vary, but I generally go easiest to hardest. \r\n2. Read the question carefully, check constraints, and figure out edge cases so they don't bite you later.  \r\n3. Figure out an algorithm for it, conceptually; this first algorithm will likely be something naive, and that's fine.\r\n4. Spend a bit of time thinking on optimization. If you think you'll be able to code something more efficient without the time sabotaging the rest of the challenge for you, do so. If you're stuck on the fence, I recommend implementing the naive algorithm, moving to the other ones, then coming back. \r\n5. Write the algorithm and debug until it works.\r\n    - For test cases, use all the example ones, and then think of some of your own if the example ones don't cover certain circumstances. Your testing process is heavily dependent on how sure you are and on how much time you have left. \r\n\r\nAfter you get something working, here are the steps I recommend to optimize:\r\n1. Look for duplicated or unnecessary work.\r\n    - For instance, a key optimization to turning the Fibonacci sequence from something exponential to linear is implementing [memoization](https://en.wikipedia.org/wiki/Memoization), which is essentially caching the result of a specific `fibonnaci(n)` call.\r\n2. Check to see if you can do any analysis at the beginning of the function that makes more algorithmically complex work later in the function easier.\r\n    - If the overall function is `O(nlog(n))`, you can get away with sorting at the beginning, as sorting is `O(nlogn)` and won't change the overall time complexity.\r\n    - You can often use things like hash maps or sets for this. Assembling them is generally roughly O(n). \r\n3. Check if you can use data structures to speed anything up.\r\n    - Sometimes, putting your data in a heap at the beginning then pulling it out in a sorted manner can be more efficient than searching through your collection in the middle. Things like that present themselves more than you'd think.\r\n    - Check out my [Data Structures Guide](/blog/data-structures-a-comprehensive-guide) for a good overview of the most prominent ones and the situations they really shine! \r\n\r\n### Whiteboarding\r\nWhiteboarding borrows most of the same advice as Coding Challenges. However, one major difference - **you get to talk to the interviewer**. This is incredibly important. The interviewer is focused on your problem solving process and the ideas going through your head, *not* if you're able to remember some random fact that makes the problem super easy. They are looking to see that you can reason your way to a solution. \r\n\r\nThis is huge for people that know their stuff or learned well from classes, but aren't great at actually writing the code. You can (and should) spend *much* more time in whiteboarding just talking through your process for thinking through an algorithm to implement. They will be much more sympathetic on someone that they know understands the concepts behind what they're writing and struggles with the code than someone that started coding right away and isn't really explaining their thoguth process. ","slug":"coding-challenges-and-whiteboarding-a-comprehensive-guide"},{"frontmatter":{"title":"Leetcode #1725 - Number Of Rectangles That Can Form The Largest Square | Python Solution \u0026 Walkthrough","author":"Anden Acitelli","date":"2021-05-21"},"markdownBody":"\r\n## Intro\r\nHey! The goal of my Leetcode series, rather than to just present the optimal solution, is to give you some background on my thought process, with the goal of making you better at thinking through fresh problems you've never seen before and coming up with a fairly good solution that doesn't need to be perfectly optimal. \r\n\r\n## Background\r\n\r\nLeetcode Page: [Leetcode #1725 - Number Of Rectangles That Can Form The Largest Square](https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/)\r\n\r\n## Solution\r\n\r\n```python\r\ndef countGoodRectangles(self, rectangles):\r\n\r\n        # Determine maximum rectangle size\r\n        largest_size = -1 # Can make either first rectangle's size or a negative number\r\n        for rectangle in rectangles:\r\n            size = self.get_length_of_square(rectangle)\r\n            if size \u003e largest_size:\r\n                largest_size = size \r\n        \r\n        # Iterate through again and count all that have that size \r\n        num_largest = 0\r\n        for rectangle in rectangles:\r\n            if self.get_length_of_square(rectangle) == largest_size:\r\n                num_largest += 1\r\n        return num_largest\r\n        \r\n    # Returns the max square size of a given rectangle \r\n    def get_length_of_square(self, rectangle):\r\n        return min(rectangle[0], rectangle[1])\r\n```\r\n\r\nDetails: \r\n- **Summary:** Iterate through once to find largest square size, then iterate through again to count how many are that big.\r\n- **Time Complexity:** O(n), where n is the size of the array. Simplified from O(n + n), as we iterate through the array twice. \r\n- **Space Complexity:** O(1), as we don't make any variables whose size scales with input size. \r\n- **Statistics:** Beat 18.70% in Time Complexity, Beat 35.50% in Space Complexity.\r\n\r\n## Potential Optimization\r\nThinking about complexity, seems like you'd theoretically *need* to look at every rectangle at least once, so I highly doubt we can get lower than O(n), even with using more memory. Space complexity is also as good as you can get already. \r\n\r\nWe can optimize a bit within O(n), though. You can do this in one iteration by keeping a count of the largest. If you find one larger than your current maximum size, this number becomes one. If you find one the same as your current maximum size, it stays zero. \r\n\r\nYou can also keep an array that stores each rectangle's computed value to replace duplicate calls to the function, but that increases the space complexity and really just doesn't seem worth it when the function is very quick in the first place. \r\n\r\n## Thought Process\r\nSimple enough that the algorithm was intuitive to think up. The helper function made it easier to get right first time through. ","slug":"leetcode-1725"},{"frontmatter":{"title":"Leetcode #1828 - Queries on Number of Points Inside a Circle | Python Solution \u0026 Walkthrough","author":"Anden Acitelli","date":"2021-05-21"},"markdownBody":"\r\n## Intro\r\nHey! The goal of my Leetcode series, rather than to just present the optimal solution, is to give you some background on my thought process, with the goal of making you better at thinking through fresh problems you've never seen before and coming up with a fairly good solution that doesn't need to be perfectly optimal. \r\n\r\n## Background\r\n\r\nLeetcode Page: [Leetcode #1725 - Queries on Number of Points Inside a Circle](https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/)\r\n\r\n## Solution\r\n\r\n```python\r\ndef countPoints(self, points, queries):\r\n        \"\"\"\r\n        :type points: List[List[int]]\r\n        :type queries: List[List[int]]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        # For each circle, loop through each point and calculate queries[j]\r\n        answer = []\r\n        for query in queries:\r\n            \r\n            # Check each point \r\n            points_in_this_circle = 0\r\n            for point in points:\r\n                if self.distance(point[0], point[1], query[0], query[1]) \u003c= query[2]:\r\n                    points_in_this_circle += 1\r\n                    \r\n            # Append for this circle to output array\r\n            answer.append(points_in_this_circle)\r\n            \r\n        return answer\r\n                \r\n    def distance(self, x1, y1, x2, y2):\r\n        return sqrt((x2 - x1)**2 + (y2 - y1)**2)\r\n```\r\n\r\nDetails: \r\n- **Summary:** Naive algorithm. Iterate through each circle, then iterate through each point for that given circle.\r\n- **Time Complexity:** `O(n * m)`, where `n` is the number of queries and `m` is the number of points. \r\n- **Space Complexity:** `O(n)`, where `n` is the number of queries.\r\n- **Statistics:** Beat 15.48% in Time Complexity, Beat 14.97% in Space Complexity.\r\n\r\n## Potential Optimization\r\nMy steps for optimization: \r\n\r\n1. **Does it seem theoretically possible to make time complexity lower?**: Oftentimes it's physically impossible to, especially if making it quicker means you can't even look at all the elements. \r\n    - I don't think we're theoretically bounded by the current complexity, so I'll look at ways to improve it. \r\n2. **Duplicate or Unnecessary Work**: Self-explanatory. \r\n    - We could probably scan for duplicate circles or duplicate points first, which would simply add n/m to our complexity, which wouldn't change it overall.\r\n3. **Time-Space Tradeoff**: Can we save any data to certain data structures in order to decrease time complexity? \r\n\r\nAfter struggling for a bit, I looked this up and it doesn't look like there's a way to do this that entirely changes the time complexity. You can do some small things to better it within the same time complexity, though. At least this serves as a good guide for how to approach them! \r\n\r\n## Thought Process\r\nMy first thought is the \"naive\" algorithm - just iterate through each query and check each point for proximity to that circle. I program this, and it works fine. ","slug":"leetcode-1828"},{"frontmatter":{"title":"Time \u0026 Space Complexity | A Review","author":"Anden Acitelli","date":"2021-05-21"},"markdownBody":"\r\n## Intro \r\nTime Complexity is possibly *the* most important concept to understand when it comes to coding challenges and technical interviews. Interviewers want to know that you approach algorithm design with a focus on efficiency. \r\n\r\nThis article is intended as a refresher on the concepts; it doesn't go extremely in-depth, but should get you feeling 90% ready for interviews. Lets get started! \r\n\r\n## Time Complexity\r\n### Overview \r\nTime Complexity is a way to describe how fast an algorithm runs. We do this by \"bounding\" the runtime by a given amount. We generally bound by magnitudes of certain variables in the function (Ex: length of an array, length/width of a grid, length of an input string, etc.). Always make sure you state what the variables you are using *mean* - this will become clearer shortly. \r\n\r\nWe have a few ways to bound the runtime of algorithms: \r\n\r\n1. Ω is a **lower bound**. If your algorithm is in Ω(n), that means the algorithm's runtime is *lower bounded* by Ω(n).\r\n2. O is an **upper bound**. If your algorithm is in O(n^2), that means the algorithm's runtime is *upper bounded* by O(n).  \r\n2. θ is a lower **and** upper bound. If your algorithm is in θ(n), that means the algorithm's runtime is *lower and upper bounded* by θ(n). This means it \r\n\r\nNote that Ω(n) (and every other given complexity through this article) is representative of a **set**. It is the set of *all* algorithms who have runtime that scale *as fast* or *faster* than an algorithm that scales linearly with n. \r\n\r\n**The industry commonly uses the term \"Big O\" AKA O(n-whatever) to mean the same thing as Big Theta here**. They want to hear something that is both a lower and upper bound. I'll ignore Sigma and Theta from here on out. \r\n\r\n### Common Runtimes\r\nVarious common runtimes, accompanied by common algorithms that have those runtimes: \r\n\r\n- **O(1)**: Constant-time, meaning it doesn't scale with the size of any input.\r\n    - Math Operations\r\n    - Array Accesses (i.e. `arr[i]`). (More Detail: These are just pointer math: `address of beginning of array` + `i * size of each element in the array`.)\r\n- **O(log(n))**: Scales logarithmically with the size of a given input of size n.\r\n    - Binary Search. (Refresher: Given a sorted list, binary search keeps intelligently dividing the array in half until it finds a given element)\r\n- **O(n)**: Scales linearly with the size of the input.\r\n    - Iterating through basically anything of a given size `n`\r\n- **O(nlog(n))**: Both linearly and logarithmically.\r\n    - Efficient search algorithms like Merge Sort and Quick Sort. This means, if your algorithm is `O(nlogn)` or worse, sorting everything beforehand using basically any language's `sort()` implementation will effectively be free in terms of time complexity, which can often help simplify the rest of the function. \r\n- **O(n^2)**: Quadratically.\r\n    - Often comes up when you have to compare every element of a collection with every other element of the collection.\r\n- **O(2^N)**: Exponential.\r\n    - Also comes up frequently with recursive stuff. *If you come up with this in an interview, they can almost always be optimized.*\r\n- **O(n!)**: Factorial.\r\n    - Often comes up with naive, non-optimized version of recursive stuff. *If you come up with this in an interview, they can almost always be optimized.*\r\n    - The \"easy\" Fibbonaci Sequence implementation. Note that Fibbonaci can be made O(n) very easily by using [memoization](https://en.wikipedia.org/wiki/Memoization), which is essentially just caching already-calculated values. \r\n\r\nFor more help with figuring out algorithmic complexity: \r\n- [My guide on Coding Challenges \u0026 Whiteboarding](/post/coding-challenges-a-comprehensive-guide)\r\n- [This guide that looks pretty good](https://adrianmejia.com/how-to-find-time-complexity-of-an-algorithm-code-big-o-notation/)\r\n- [This other guide that looks pretty good](https://medium.com/dataseries/how-to-calculate-time-complexity-with-big-o-notation-9afe33aa4c46)\r\n\r\n### Math Simplification\r\nA few important rules:\r\n\r\n1. If anything's getting added, the dominant term wins.\r\n    - `O(n + 23)` =\u003e `O(n)`\r\n    - `O(n^3 + n^2 + 5n)` =\u003e `O(n^3)`\r\n    - `O(n^2 + n^2 * log(n)) =\u003e `O(n^2 * log(n))\r\n2. Multiplication does *not* follow the same rule, but you can take out anything that's a constant. \r\n    - `O(n * m)`, when n/m are both variables, *cannot* be simplified. \r\n    - `O(23n + 5)` =\u003e O(n)` \r\n\r\n## Space Complexity\r\n### Overview\r\nSpace complexity is similar to time complexity, but measures how quickly the amount of memory a given algorithm will take scales. It's more rarely asked about, but many employers, especially prestigious ones, will ask for both space and time complexity. \r\n\r\nSpace complexity *doesn't usually include the input*. Sometimes the term **auxilary space** is used to distinguish this - it refers to just new memory allocated by the function, including whatever it returns or outputs. \r\n\r\nCalculating this is usually pretty intuitive, so I won't go very in-depth. I usually just figure out what the greatest amount of stuff in memory at any given time will be and figure out what it scales by. \r\n\r\nMore resources on space complexity: \r\n- [A good guide](https://www.faceprep.in/data-structures/space-complexity/)\r\n- [Another good guide](https://www.studytonight.com/data-structures/space-complexity-of-algorithms), which looks at it in terms of actual memory. Interviewers are generally just curious by what magnitude it scales, but it's useful (and often mandatory) to know what's going on behind the scenes in things like loops. ","slug":"time-and-space-complexity-a-review"},{"frontmatter":{"title":"A Guide to Getting a Job as a Computer Science Student","author":"Anden Acitelli","date":"2021-05-20"},"markdownBody":"\r\n## Intro\r\nHey! I wasn't able to find a comprehensive and concise guide that took me through the entire process of searching for jobs as a Computer Science student, so I figured I'd write one up. \r\n\r\nNote that I hope to amend this article at a later date with more sources; I read about this stuff a lot and am just pulling from a few years of miscellaneous information pulled from all sorts of places. The tl;dr is that I don't have insider information or anything, but consider myself well-researched, and most of this information isn't personal opinion. \r\n\r\nI like to split up progress in hiring into the \"stages\" you go through:\r\n\r\n1. Pre-Application\r\n2. The Application\r\n3. Coding Challenges\r\n4. Technical Interviews \u0026 Whiteboarding\r\n5. Behavioral Interviews\r\n6. Offer!\r\n\r\n## 1. Pre-Application\r\nBefore you even apply, you want to be doing some things that make things easier for you come hiring season. This mostly boils down to networking. I wish I'd done more. Having a good network can easily make up for other parts of your application that aren't great, or let you skip parts of it.  \r\n\r\n1. **LinkedIn**: Make sure you keep this at least reasonably up to date, and cultivate your network where you can. Inbound opportunities (recruiters reaching out to *you*) are very valuable.\r\n2. **Networking Events**: Oftentimes universities and university organizations host tons of networking events. Go, show your resume off, connect with everyone you meet on LinkedIn. It's often useful to approach this from a perspective of learning about the people, what they do, and what the industry is like, rather than explicitly being there for a job. Show interest in them; that will distinguish you. \r\n\r\n## 2. The Application\r\nMost of this is your resume. A killer resume is **concise and straightforward, number-based, and gets through ATS**. You want to get through ATS, then have a resume that is quick and non-distracting for a hiring manager to read through. Focus on getting the maximum information conveyed per word. \r\n\r\n1. **Concise and Straightforward**: Do *not* use filler words. A line 75% of the way across the page that is packed with information is far better than a sparser line that goes the whole way across. Hiring managers value someone who can state concretely what they learned.\r\n2. **Number-based**: If you are able to give quantitative statements (rather than qualitative, wishy-washy language), it looks amazing. \r\n3. **ATS Compatible**: If you highlight all the text on your resume and paste it into a text document, an ATS-optimized resume should be ordered correctly and not have any extra words.\r\n    - Stuff like LaTeX can often mess this up pretty bad. For this reason, I recommend using a .docx resume and exporting that; it's what I personally do, and what's been recommended to me by a few people. \r\n\r\n**Cover Letters - Yes or No?**\r\n\r\nWhether or not you do a cover letter is mostly just a function of how much you want the specific position. If you're just getting a bunch of applications out, I personally feel that time is better spent getting more applications out, but if you're focused on like 10-20 places, it's probably worth it.\r\n\r\nYour cover letter should be short and sweet, ideally just a paragraph. Seriously - don't make this *any* longer than you have to to get your point across, as most hiring managers don't like opening a PDF and seeing three long paragraphs. You don't need filler or to recap anything that's on your resume. Use it to say anything relevant not on your resume or to say something you think will distinguish yourself from other candidates. \r\n\r\n## 3. Coding Challenges\r\nThe majority of the solution to getting good at these is to practice on sites like Leetcode and Hackerrank, no way around it. \r\n\r\nIn terms of strategy, some pointers:\r\n- Coding challenges are more focused on just getting a working solution that has good time complexity. Your goal during practice should align accordingly. Don't worry too much about commenting stuff out or writing super clean code, just worry about the end result. Get something working, then optimize it with what time you have left. \r\n- Use Leetcode/Hackerrank's mock interview feature to put yourself under the same time crunch. Don't skimp on it. \r\n- Most challenges will be something along the lines of a Leetcode Easy and a Medium. Completely dependent on the position and the company, though. \r\n\r\n## 4. Technical Interviews \u0026 Whiteboarding\r\nThe main advantage with technical interviews is that you can talk to your interviewer. \r\n\r\nMain strategy points:\r\n- Focus more on being organized and communicating your process to your interviewer. They care more about how you come to your solution and that you genuinely know what you're talking about than whether you completed it. \r\n- A lot of companies will deliberately give you difficult problems, and you aren't expected to get the answer quickly. I believe the interviewers themselves are the ones that decide the problems, actually (source: CTCI?), but that likely depends on the company. \r\n- Communicate what you *do* know. If you're someone in university, you know a lot more theory than anyone in bootcamps or so on. Use that. \r\n\r\n## 5. Behavioral Interviews\r\nPractice is also pretty important for these, but making sure you practice correctly is important. \r\n\r\nThe general advice is to get all your experiences together and organized, then just find a ton of questions to mock interview yourself with and just drill them until it's more fluid for you. Your brain starts to internalize stuff, but it's not a short process. \r\n\r\n## 6. Offer!\r\nGetting an offer is great, but it can often be worth it to try and negotiate, especially if you have more than one offer. I can't speak authoritatively on this, but [this blog post](https://www.kalzumeus.com/2012/01/23/salary-negotiation/) is generally considered the holy grail of SWE Negotation, so give it a read.\r\n\r\n## FAQ\r\n**How should my preparation changed based on if I'm going for Full-Time vs. an Internship?**\r\n\r\nThe only thing that really changes is how thoroughly you're interviewed. There's more focus on cultural fit and technical proficiency, so make sure you have behavioral problems down and are good at whiteboarding. \r\n\r\nHere's what the process generally looks like:\r\n- **Internship**: Coding Challenge \u003e Phone Screen (Behavioral) \u003e Technical Interview \u003e Offer\r\n- **Full Time**: Coding Challenge \u003e Phone Screen (Behavioral) \u003e Several interviews, both behavioral and technical, generally all in one day \u003e Offer","slug":"computer-science-job-search-guide"},{"frontmatter":{"title":"Leetcode #200 - Number of Islands | Python Solution \u0026 Walkthrough","author":"Anden Acitelli","date":"2021-05-20"},"markdownBody":"\r\n## Intro\r\nHey! The goal of my Leetcode series, rather than to just present the optimal solution, is to give you some background on my thought process, with the goal of making you better at thinking through fresh problems you've never seen before and coming up with a fairly good solution that doesn't need to be perfectly optimal. \r\n\r\n## Background\r\n\r\nLeetcode Page: [Leetcode #200 - Number of Islands](https://leetcode.com/problems/number-of-islands/)\r\n\r\n## Solution\r\n\r\n```python\r\n# After we start exploration from a given island, we add it to this\r\n    # If recursing from a new point ever goes to something that's already in there, we know that that new one we\r\n    # started recursing at is part of a preexisting island and we shouldn't treat it as a new island \r\n    found = set()\r\n    found_this_iteration = set()\r\n    \r\n    def numIslands(self, grid):\r\n        \"\"\"\r\n        :type grid: List[List[str]]\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        self.found = set()\r\n        self.found_this_iteration = set()\r\n        \r\n        # One approach is to modify the grid so that there's zeroes along the rim, but it's doable \r\n        # and more optimal to just add edge cases for the \"edge\" logic in the other function  \r\n        num_islands = 0\r\n        for x in range(len(grid[0])):\r\n            for y in range(len(grid)):\r\n                                \r\n                # Check if current island is in a new island\r\n                if grid[y][x] == \"1\" and self.isNewIsland(x, y, grid):\r\n                    num_islands += 1 \r\n                    \r\n                # Shift tiles found this iteration to the overall record of things that are in an island \r\n                for elem in self.found_this_iteration:\r\n                    self.found.add(elem)\r\n                self.found_this_iteration = set()\r\n            \r\n        return num_islands\r\n        \r\n    # Returns False if we find an already existing land block, True otherwise\r\n    def isNewIsland(self, x, y, grid):\r\n        \r\n        # Check all four corners (respecting edge cases); recurse on anything that's a 1\r\n        # If the current x/y is already in `found`, return False\r\n        # If any of them return `False`, whole function returns False\r\n        # Only return True if none of the paths led to something already part of an Island \r\n\r\n        # If we already covered this one in the current recursive cycle, ignore it\r\n        if (x, y) in self.found_this_iteration:\r\n            return True \r\n        \r\n        # If this one belongs to a preexisting island, return False \r\n        if (x, y) in self.found:\r\n            return False \r\n        \r\n        # Otherwise, this belongs to the current recursion chain's island\r\n        self.found_this_iteration.add((x, y))\r\n        \r\n        # Left\r\n        if x \u003e 0:\r\n            if grid[y][x - 1] == \"1\" and not self.isNewIsland(x - 1, y, grid):\r\n                return False\r\n        \r\n        # Right\r\n        if x \u003c len(grid[0]) - 1:\r\n             if grid[y][x + 1] == \"1\" and not self.isNewIsland(x + 1, y, grid):\r\n                return False\r\n        \r\n        # Top\r\n        if y \u003e 0:\r\n             if grid[y - 1][x] == \"1\" and not self.isNewIsland(x, y - 1, grid):\r\n                return False \r\n        \r\n        # Bottom\r\n        if y \u003c len(grid) - 1:\r\n             if grid[y + 1][x] == \"1\" and not self.isNewIsland(x, y + 1, grid):\r\n                return False\r\n        \r\n        return True \r\n```\r\n\r\n**Summary:** Essentially a DFS. Start recursion on each 1 in the array. Track which islands we've seen during the current \"recursion chain\" and ignore them if we find them again. If, during a recursion chain, we find one we've found in a previous recursion chain, we are part of the same chain as that one.  \r\n\r\n**Time Complexity:** `O(n x m)`, where n is width and m is height. \r\n\r\n**Space Complexity:** O(n x m), as we need to make sets that are of magnitude \u003cnumber of elements in the grid\u003e. \r\n\r\n**Statistics**: Faster than 6.70%, Memory Usage less than 6.27%. \r\n\r\n**Future Optimization**: Honestly not sure. There's some redundancy in there, and it's probably possible to not keep these gigantic sets every time. \r\n\r\n## Thought Process\r\nAfter reading the question a few times, the first solution that pops into my head is something akin to graph traversal. You iterate through each part of the grid, then essentially recurse on every neighbor. You count this as on a new island if none of the other ones you find are already on an island. The important thing is that you have to keep a cache of which islands you've already started the recursion on, as if you find an island that was already the same, that means the one you just started on is part of a different, already-found island. \r\n\r\nI outlined the functions (one is the start, one is the recursive part) and it looks something like this: \r\n\r\n```python\r\n# After we start exploration from a given island, we add it to this\r\n    # If recursing from a new point ever goes to something that's already in there, we know that that new one we\r\n    # started recursing at is part of a preexisting island and we shouldn't treat it as a new island \r\n    found = set()\r\n    \r\n    def numIslands(self, grid):\r\n        \"\"\"\r\n        :type grid: List[List[str]]\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        # One approach is to modify the grid so that there's zeroes along the rim, but it's doable \r\n        # and more optimal to just add edge cases for the \"edge\" logic in the other function  \r\n        num_islands = 0\r\n        for x in range(len(grid)):\r\n            for y in range(len(grid[0])):\r\n                if self.isNewIsland(x, y, grid):\r\n                    num_islands += 1 \r\n                found.add((x, y))\r\n            \r\n        return num_islands\r\n        \r\n    # Returns False if we find an already existing land block, True otherwise\r\n    def isNewIsland(x, y, grid):\r\n        \r\n        # Check all four corners (respecting edge cases); recurse on anything that's a 1\r\n        # If the current x/y is already in `found`, return False\r\n        # If any of them return `False`, whole function returns False\r\n        # Only return True if none of the paths led to something already part of an Island \r\n        \r\n        # Left\r\n        if x \u003e 0:\r\n            if not self.isNewIsland(x - 1, y, grid):\r\n                return False\r\n        \r\n        # Right\r\n        if x \u003c len(grid) - 1:\r\n             if not self.isNewIsland(x + 1, y, grid):\r\n                return False\r\n        \r\n        # Top\r\n        if y \u003e 0:\r\n             if not self.isNewIsland(x, y - 1, grid):\r\n                return False \r\n        \r\n        # Bottom\r\n        if y \u003c= len(grid[0]) - 1:\r\n             if not self.isNewIsland(x, y + 1, grid):\r\n                return False\r\n        \r\n        return True \r\n```\r\n\r\nTime to try it out and see how it does! \r\n\r\nFixes: \r\n\r\n1. Syntax Error: Adding `self` as an argument to `isNewIsland()` \r\n2. Max Recursion Depth Exceeded: I realize quickly that the function will just alternate between two land segments. With recursion, you have to consciously make the problem a little smaller each call, but I never do that. Potential fixes:\r\n    - Don't call it on the direction that it \"came from\". This can still result in square-based loops, but it's a thought. \r\n    - Adjust `found` inside the loop itself. I think this is the best approach; I figure out I'll have to do the \"does this exist checK\" at the beginning of the function, then add this. \r\n3. Not Giving Any Results\r\n    - To test this, I add print statements for what \"cell\" it's starting on and to view what \"found\" looks like after each call \r\n    - After a bit of debugging, I figure out that, even after I set found, it can go in a circle and essentially just say \"yeah, this is in the same island as itself, so it's not a new island\". A clean way to do this would be to keep a set of land covered *during this recursive cycle* and only add that set to `found` after we're entirely done recursing. We then only check for the island thing in `found` so that we aren't checking against the current island. \r\n\r\nAfter these fixes, it passes the basic test case. I test it with the other sample test cases provided, and I get a pretty generic error. I return 2 islands, when the right result is 3. My thoughts when debugging: \r\n\r\n1. I see from my output that I detected the very last island (3, 3) as a new island. This seems a little happenstance, so I reexamine how I handle edge cases. \r\n    - I realize pretty quickly that I mixed up rows and columns, meaning it would mess up on anything that didn't have the same number of rows and columns. \r\n    - Switching that instead gives me a \"list index out of range\" question, so I double-check that len(grid) and len(grid[0]) are giving me what they should; this would be the height and width of the grid, respectively. \r\n    - I realize the error is that I have x and y switched. Oops. \r\n\r\n2. That doesn't fix everything; the following array gives me 2 as an answer rather than 3: \r\n   \r\n```python\r\n[ 1 1 0 0 0\r\n1 1 0 0 0\r\n0 0 1 0 0\r\n0 0 0 1 1]\r\n```\r\n- It seems to be completely skipping the top-left island, for some reason. \r\n- The issue ended up being something specific to Leetcode. They were feeding in several consecutive inputs, and my class variables weren't being reset, so it was starting out at (0, 3) because everything before was already in `self.found`. \r\n\r\nUpon submitting it, Leetcode gives me a \"Time Limit Exceeded\" when it gives me an input of a bunch of zeroes on a row, then a bunch of ones in a row, then keeps going for a *long* time. I take this as tacit proof that mine works, just isn't as efficient as they'd like it to be. Guess it's time to figure out if I can optimize! It *should* currently just be one iteration per tile, which I'd imagine is as efficient as you can fundamentally get, so I'm a little puzzled. \r\n\r\nSpeed-up attempts:\r\n\r\n- A few times when I check for a given coordinate more than once in `self.found`\r\n- The `self.found_this_iteration` check is likely much quicker than the `self.found` check, so I switched the order \r\n\r\nThose fixes were enough to push this to an Accepted answer. ","slug":"leetcode-200"},{"frontmatter":{"title":"Leetcode #1832 - Check if the Sentence Is Pangram | Python Solution \u0026 Walkthrough","author":"Anden Acitelli","date":"2021-05-19"},"markdownBody":"\r\n## Intro\r\nHey! The goal of my Leetcode series, rather than to just present the optimal solution, is to give you some background on my thought process, with the goal of making you better at thinking through fresh problems you've never seen before and coming up with a fairly good solution that doesn't need to be perfectly optimal. \r\n\r\n## Background\r\n\r\nLeetcode Page: [Leetcode #1832 - Check if the Sentence Is Pangram](https://leetcode.com/problems/check-if-the-sentence-is-pangram/)\r\n\r\n## Solution\r\n**Note:** While time complexity doesn't change, initializing a set to the set of alphabet letters, then removing them as they're found, then checking if `len(set)` is zero every time is likely much faster. Space complexity, while it doesn't change in magnitude, is a little better as well. \r\n\r\n```python\r\ndef checkIfPangram(self, sentence):        \r\n    alphabetMap = {\r\n        \"a\": False, \r\n        \"b\": False, \r\n        \"c\": False, \r\n        \"d\": False, \r\n        \"e\": False, \r\n        \"f\": False, \r\n        \"g\": False, \r\n        \"h\": False, \r\n        \"i\": False, \r\n        \"j\": False, \r\n        \"k\": False, \r\n        \"l\": False, \r\n        \"m\": False, \r\n        \"n\": False, \r\n        \"o\": False, \r\n        \"p\": False, \r\n        \"q\": False, \r\n        \"r\": False, \r\n        \"s\": False, \r\n        \"t\": False, \r\n        \"u\": False, \r\n        \"v\": False, \r\n        \"w\": False, \r\n        \"x\": False, \r\n        \"y\": False, \r\n        \"z\": False, \r\n    }\r\n    \r\n    for letter in sentence:\r\n        alphabetMap[letter] = True\r\n        \r\n    for key, value in alphabetMap.items():\r\n        if value == False:\r\n            return False\r\n    return True \r\n```\r\n\r\n**Summary:** Make a map to track whether each letter has been found, then iterate through the sentence, setting each one to indicate it was found. If any are still False at the end, return False. \r\n\r\n**Time Complexity:** O(n) - simplified from O(n + 26), as we iterate once through the sentence and once through a dictionary of size 26. You can eliminate the +26 by keeping a set of all the letters of the alphabet, removing them when they're found, then returning True if the set is empty at the end, which is presumably a constant time operation. \r\n\r\n**Space Complexity:** O(1), as we simply make a 26-size map, which is constant size.\r\n\r\n## Thought Process\r\nSeems pretty easy surface-level. Some form of iterating through and just modifying a list should be fine.\r\n\r\nMy initial thought is to make a map of the alphabet, something like this, where you track whether you found it yet:\r\n\r\n```python\r\n{\r\n    \"a\": False, \r\n    \"b\": False, \r\n    ...\r\n}\r\n```\r\n\r\nAfter iterating through and checking every letter, you then iterate through this alphabet map, returning False if you find even a single False, and returning True if they were all true. I programmed this and it ended up being pretty easy; see the \"solution\" section. \r\n\r\nProbably would have been cleaner to just make a set of the alphabet letters and remove each letter from the set as it was found, then return True if the set was empty at the end. ","slug":"leetcode-1832"}],"title":"Blog - Anden Acitelli","description":"Full of my thoughts on all sorts of useful things!"},"__N_SSG":true},"page":"/blog","query":{},"buildId":"z1-zhy4bRepDESy5GmGY_","assetPrefix":".","runtimeConfig":{},"nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width, initial-scale=1","className":"jsx-2140933378"}],["meta",{"charSet":"utf-8","className":"jsx-2140933378"}],["meta",{"name":"Description","content":"Full of my thoughts on all sorts of useful things!","className":"jsx-2140933378"}],["title",{"className":"jsx-2140933378","children":"Blog - Anden Acitelli"}]]}</script><script nomodule="" src="./_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="./_next/static/chunks/main-e42d054aa95b944b20b8.js" async=""></script><script src="./_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="./_next/static/chunks/framework.1d36bc031662b4dc4c28.js" async=""></script><script src="./_next/static/chunks/commons.8efcb680d37dd3ee49c0.js" async=""></script><script src="./_next/static/chunks/56d41ae4a9190e27ed3b62860efb4e91cb9f6cf4.413db218b03418cdd16a.js" async=""></script><script src="./_next/static/chunks/pages/_app-c80169169d682623989a.js" async=""></script><script src="./_next/static/chunks/ce1ec70fd8cb3022c6ba5208dd089b6243e5bf76.d2c9cf82cc172977f3f6.js" async=""></script><script src="./_next/static/chunks/pages/blog-66917b58afde6367a706.js" async=""></script><script src="./_next/static/z1-zhy4bRepDESy5GmGY_/_buildManifest.js" async=""></script><script src="./_next/static/z1-zhy4bRepDESy5GmGY_/_ssgManifest.js" async=""></script></body></html>